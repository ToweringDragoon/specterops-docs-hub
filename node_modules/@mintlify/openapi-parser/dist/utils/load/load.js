import{ERRORS as e}from"../../configuration/index.js";import{getEntrypoint as i}from"../getEntrypoint.js";import{getListOfReferences as r}from"../getListOfReferences.js";import{makeFilesystem as s}from"../makeFilesystem.js";import{normalize as t}from"../normalize.js";async function n(o,f){const c=[];if(f?.filesystem?.find((e=>e.filename===o)))return{specification:i(f.filesystem)?.specification,filesystem:f.filesystem,errors:c};const l=f?.plugins?.find((e=>e.check(o)));let a;if(l)try{a=t(await l.get(o))}catch(i){if(f?.throwOnError)throw new Error(e.EXTERNAL_REFERENCE_NOT_FOUND.replace("%s",o));return c.push({code:"EXTERNAL_REFERENCE_NOT_FOUND",message:e.EXTERNAL_REFERENCE_NOT_FOUND.replace("%s",o)}),{specification:null,filesystem:[],errors:c}}else a=t(o);if(void 0===a){if(f?.throwOnError)throw new Error("No content to load");return c.push({code:"NO_CONTENT",message:e.NO_CONTENT}),{specification:null,filesystem:[],errors:c}}let m=s(a,{filename:f?.filename??null});const E=(f?.filename?m.find((e=>e.filename===f?.filename)):i(m)).references??r(a);if(0===E.length)return{specification:i(m)?.specification,filesystem:m,errors:c};for(const e of E){const i=f?.plugins?.find((i=>i.check(e)));if(!i)continue;const r=i.check(e)&&i.resolvePath?i.resolvePath(o,e):e;if(m.find((i=>i.filename===e)))continue;const{filesystem:s,errors:t}=await n(r,{...f,filename:e});c.push(...t),m=[...m,...s.map((e=>({...e,isEntrypoint:!1})))]}return{specification:i(m)?.specification,filesystem:m,errors:c}}export{n as load};
