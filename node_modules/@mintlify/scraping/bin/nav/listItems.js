import { EXIT, visit } from 'unist-util-visit';
import { dedupedAppend } from '../utils/append.js';
import { framework } from '../utils/detectFramework.js';
import { findFirstChild } from '../utils/firstChild.js';
import { removeTrailingSlash } from '../utils/strings.js';
import { getText } from '../utils/text.js';
import { retrieveNavItems } from './retrieve.js';
export function processListItem(node, opts = {
    sectionTagName: 'div',
    childListTagName: 'ul',
    title: undefined,
}) {
    const link = findFirstChild(node, 'a');
    if (!link)
        return undefined;
    let linkHref = undefined;
    linkHref = link.properties.href;
    if (linkHref === undefined || linkHref === '#') {
        return undefined;
    }
    let isApiReferenceLink = false;
    visit(link, 'element', function (subNode) {
        if (subNode.tagName === 'span' &&
            Array.isArray(subNode.properties.className) &&
            subNode.properties.className.includes('rm-APIMethod')) {
            isApiReferenceLink = true;
            return EXIT;
        }
    });
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    if (isApiReferenceLink)
        return undefined;
    if (linkHref.startsWith('/'))
        linkHref = linkHref.substring(1);
    const sectionHeader = findFirstChild(node, opts.sectionTagName);
    const childList = findFirstChild(node, opts.childListTagName);
    let title = opts.title;
    if (!title) {
        title = getText(link) || getText(sectionHeader) || '';
        if (framework.vendor === 'readme') {
            title = getText(sectionHeader) || getText(link) || '';
        }
    }
    if (!childList) {
        return linkHref;
    }
    let childEntries = retrieveNavItems(childList);
    const newLink = childEntries.find((child) => typeof child === 'string' && child.startsWith(linkHref))
        ? removeTrailingSlash(linkHref) + '/mintie_overview'
        : linkHref;
    if (childEntries.includes(linkHref)) {
        childEntries.forEach((child, index) => {
            if (child === linkHref)
                childEntries[index] = newLink;
        });
    }
    else {
        childEntries = dedupedAppend(newLink, childEntries, true);
    }
    return { group: title, pages: dedupedAppend(newLink, childEntries, true) };
}
//# sourceMappingURL=listItems.js.map