import { visit, CONTINUE, EXIT } from 'unist-util-visit';
import { assertIsDefined } from '../assert.js';
import { turnChildrenIntoMdx } from '../utils/children.js';
function tabContainsOnlyCode(node) {
    let tabsCount = 0;
    let onlyCodeCount = 0;
    visit(node, 'element', function (subNode) {
        if (subNode.properties.role && subNode.properties.role === 'tabpanel')
            tabsCount++;
        visit(subNode, 'element', function (tabNode, index, parent) {
            if (tabNode.tagName === 'button' && typeof index === 'number' && parent) {
                parent.children.splice(index, 1);
            }
        });
        if (subNode.children[0] &&
            subNode.children[1] &&
            subNode.children[2] &&
            subNode.children[0].type === 'element' &&
            subNode.children[0].children.length === 1 &&
            subNode.children[1].type === 'element' &&
            subNode.children[1].children.length === 1 &&
            subNode.children[2].type === 'element' &&
            subNode.children[2].children.length > 1 &&
            subNode.children[2].children.length < 4 &&
            subNode.children[2].children.find((child) => child.type === 'element' && (child.tagName === 'pre' || child.tagName === 'code'))) {
            return onlyCodeCount++;
        }
    });
    return onlyCodeCount === tabsCount;
}
export function gitBookScrapeCodeGroup(node, _, parent) {
    if (node.tagName !== 'div' || !node.properties.role || node.properties.role !== 'tablist') {
        return undefined;
    }
    if (!tabContainsOnlyCode(node))
        return undefined;
    const titles = [];
    visit(node, 'element', function (subNode) {
        if (subNode.tagName !== 'button')
            return CONTINUE;
        visit(subNode, 'text', function (textNode) {
            titles.push(textNode.value);
            return EXIT;
        });
    });
    assertIsDefined(parent);
    parent.children.shift();
    let lang = '';
    visit(node, 'element', function (subNode) {
        if (subNode.tagName === 'code' && 'id' in subNode.properties) {
            lang = subNode.properties.id;
            return EXIT;
        }
    });
    const children = turnChildrenIntoMdx(parent.children);
    const tabChildren = [];
    for (let childIndex = 0; childIndex < children.length; childIndex++) {
        const child = children[childIndex];
        tabChildren.push({
            type: 'code',
            lang: lang,
            meta: titles[childIndex],
            value: child.value,
        });
    }
    const newNode = {
        type: 'element',
        tagName: 'CodeGroup',
        properties: {},
        children: tabChildren,
    };
    return newNode;
}
export function readmeScrapeCodeGroup(node, _, parent) {
    if (node.tagName !== 'div' ||
        !node.properties.className ||
        !Array.isArray(node.properties.className) ||
        !node.properties.className.includes('CodeTabs')) {
        return undefined;
    }
    if (node.children.length !== 2 || !node.children[0] || !node.children[1])
        return undefined;
    const tabTitles = node.children[0];
    const titles = [];
    visit(tabTitles, 'element', function (subNode) {
        visit(subNode, 'text', function (textNode) {
            titles.push(textNode.value);
            return EXIT;
        });
    });
    assertIsDefined(parent);
    node.children.shift();
    let lang = '';
    visit(node, 'element', function (subNode, _, subParent) {
        if (subNode.tagName === 'code' &&
            subParent &&
            subParent.type === 'element' &&
            subParent.tagName === 'pre' &&
            'dataLang' in subNode.properties) {
            lang = subNode.properties.dataLang;
            return EXIT;
        }
    });
    const children = turnChildrenIntoMdx(node.children);
    const tabChildren = [];
    for (let childIndex = 0; childIndex < children.length; childIndex++) {
        const child = children[childIndex];
        tabChildren.push({
            type: 'code',
            lang: lang,
            meta: titles[childIndex],
            value: child.value,
        });
    }
    const newNode = {
        type: 'element',
        tagName: 'CodeGroup',
        properties: {},
        children: tabChildren,
    };
    return newNode;
}
export function docusaurusScrapeCodeGroup(node, _, parent) {
    if (node.tagName !== 'div' || !node.properties.role || node.properties.role !== 'tablist') {
        return undefined;
    }
    if (!tabContainsOnlyCode(node))
        return undefined;
    const titles = [];
    visit(node, 'element', function (subNode) {
        if (subNode.tagName !== 'li')
            return CONTINUE;
        visit(subNode, 'text', function (textNode) {
            titles.push(textNode.value);
            return EXIT;
        });
    });
    assertIsDefined(parent);
    parent.children.shift();
    let lang = '';
    visit(node, 'element', function (subNode) {
        if (Array.isArray(subNode.properties.className) && subNode.properties.className.length > 0) {
            lang = subNode.properties.className[0];
            lang = lang.replace('language-', '');
        }
    });
    const children = turnChildrenIntoMdx(parent.children);
    const tabChildren = [];
    for (let childIndex = 0; childIndex < children.length; childIndex++) {
        const child = children[childIndex];
        tabChildren.push({
            type: 'code',
            lang: lang,
            meta: titles[childIndex],
            value: child.value,
        });
    }
    const newNode = {
        type: 'element',
        tagName: 'CodeGroup',
        properties: {},
        children: tabChildren,
    };
    return newNode;
}
//# sourceMappingURL=CodeGroup.js.map