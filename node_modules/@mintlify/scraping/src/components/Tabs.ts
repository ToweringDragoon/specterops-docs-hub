import type { Element, ElementContent } from 'hast';
import { visit, CONTINUE, EXIT } from 'unist-util-visit';

import { assertIsDefined } from '../assert.js';
import type { HastNode, HastNodeIndex, HastNodeParent } from '../types/hast.js';
import { turnChildrenIntoMdx } from '../utils/children.js';

export function gitBookScrapeTabs(
  node: HastNode,
  _: HastNodeIndex,
  parent: HastNodeParent
): Element | undefined {
  if (node.tagName !== 'div' || !node.properties.role || node.properties.role !== 'tablist') {
    return undefined;
  }

  const titles: Array<string> = [];
  visit(node, 'element', function (subNode) {
    if (subNode.tagName !== 'button') return CONTINUE;
    visit(subNode, 'text', function (textNode) {
      titles.push(textNode.value);
      return EXIT;
    });
  });

  assertIsDefined(parent);
  parent.children.shift();

  const children = turnChildrenIntoMdx(parent.children) as Array<ElementContent>;
  const tabChildren: Array<ElementContent> = [];
  for (let childIndex = 0; childIndex < children.length; childIndex++) {
    const child = children[childIndex];
    if (child) {
      tabChildren.push({
        type: 'element',
        tagName: 'Tab',
        properties: {
          title: titles[childIndex],
        },
        children: [child],
      });
    }
  }

  const newNode: Element = {
    type: 'element',
    tagName: 'Tabs',
    properties: {},
    children: tabChildren as Array<ElementContent>,
  };

  return newNode;
}

export function readmeScrapeTabs(
  node: HastNode,
  _: HastNodeIndex,
  parent: HastNodeParent
): Element | undefined {
  if (
    (node.tagName !== 'div' && node.tagName !== 'a') ||
    !node.properties.className ||
    !Array.isArray(node.properties.className) ||
    !node.properties.className.includes('tabbed-component')
  ) {
    return undefined;
  }

  if (node.children.length < 2 || !node.children[0] || !node.children[1]) return undefined;
  const tabTitles = node.children[0];

  const titles: Array<string> = [];
  visit(tabTitles, 'element', function (subNode) {
    visit(subNode, 'text', function (textNode) {
      titles.push(textNode.value);
      return EXIT;
    });
  });

  assertIsDefined(parent);
  node.children.shift();

  const children = turnChildrenIntoMdx(node.children) as Array<ElementContent>;
  const tabChildren: Array<ElementContent> = [];
  for (let childIndex = 0; childIndex < children.length; childIndex++) {
    const child = children[childIndex];
    if (child) {
      tabChildren.push({
        type: 'element',
        tagName: 'Tab',
        properties: {
          title: titles[childIndex],
        },
        children: [child],
      });
    }
  }

  const newNode: Element = {
    type: 'element',
    tagName: 'Tabs',
    properties: {},
    children: tabChildren as Array<ElementContent>,
  };

  return newNode;
}

export function docusaurusScrapeTabs(
  node: HastNode,
  _: HastNodeIndex,
  parent: HastNodeParent
): Element | undefined {
  if (node.tagName !== 'div' || !node.properties.role || node.properties.role !== 'tablist') {
    return undefined;
  }

  const titles: Array<string> = [];
  visit(node, 'element', function (subNode) {
    if (subNode.tagName !== 'li') return CONTINUE;
    visit(subNode, 'text', function (textNode) {
      titles.push(textNode.value);
      return EXIT;
    });
  });

  assertIsDefined(parent);
  parent.children.shift();

  const children = turnChildrenIntoMdx(parent.children) as Array<ElementContent>;
  const tabChildren: Array<ElementContent> = [];
  for (let childIndex = 0; childIndex < children.length; childIndex++) {
    const child = children[childIndex];
    if (child) {
      tabChildren.push({
        type: 'element',
        tagName: 'Tab',
        properties: {
          title: titles[childIndex],
        },
        children: [child],
      });
    }
  }

  const newNode: Element = {
    type: 'element',
    tagName: 'Tabs',
    properties: {},
    children: tabChildren as Array<ElementContent>,
  };

  return newNode;
}
