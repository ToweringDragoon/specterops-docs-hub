import type { Element, ElementContent } from 'hast';
import type { Code } from 'mdast';
import { visit, CONTINUE, EXIT } from 'unist-util-visit';

import { assertIsDefined } from '../assert.js';
import type { HastNode, HastNodeIndex, HastNodeParent } from '../types/hast.js';
import { turnChildrenIntoMdx } from '../utils/children.js';

function tabContainsOnlyCode(node: Element): boolean {
  let tabsCount = 0;
  let onlyCodeCount = 0;

  visit(node, 'element', function (subNode) {
    if (subNode.properties.role && subNode.properties.role === 'tabpanel') tabsCount++;
    visit(subNode, 'element', function (tabNode, index, parent) {
      if (tabNode.tagName === 'button' && typeof index === 'number' && parent) {
        parent.children.splice(index, 1);
      }
    });
    if (
      subNode.children[0] &&
      subNode.children[1] &&
      subNode.children[2] &&
      subNode.children[0].type === 'element' &&
      subNode.children[0].children.length === 1 &&
      subNode.children[1].type === 'element' &&
      subNode.children[1].children.length === 1 &&
      subNode.children[2].type === 'element' &&
      subNode.children[2].children.length > 1 &&
      subNode.children[2].children.length < 4 &&
      subNode.children[2].children.find(
        (child) => child.type === 'element' && (child.tagName === 'pre' || child.tagName === 'code')
      )
    ) {
      return onlyCodeCount++;
    }
  });
  return onlyCodeCount === tabsCount;
}

export function gitBookScrapeCodeGroup(
  node: HastNode,
  _: HastNodeIndex,
  parent: HastNodeParent
): Element | undefined {
  if (node.tagName !== 'div' || !node.properties.role || node.properties.role !== 'tablist') {
    return undefined;
  }

  if (!tabContainsOnlyCode(node)) return undefined;

  const titles: Array<string> = [];
  visit(node, 'element', function (subNode) {
    if (subNode.tagName !== 'button') return CONTINUE;
    visit(subNode, 'text', function (textNode) {
      titles.push(textNode.value);
      return EXIT;
    });
  });

  assertIsDefined(parent);
  parent.children.shift();

  let lang = '';
  visit(node, 'element', function (subNode) {
    if (subNode.tagName === 'code' && 'id' in subNode.properties) {
      lang = subNode.properties.id as string;
      return EXIT;
    }
  });

  const children = turnChildrenIntoMdx(parent.children) as Array<ElementContent>;
  const tabChildren: Array<ElementContent> = [];
  for (let childIndex = 0; childIndex < children.length; childIndex++) {
    const child = children[childIndex];
    tabChildren.push({
      type: 'code',
      lang: lang,
      meta: titles[childIndex],
      value: (child as unknown as Code).value,
    } as unknown as ElementContent);
  }

  const newNode: Element = {
    type: 'element',
    tagName: 'CodeGroup',
    properties: {},
    children: tabChildren as Array<ElementContent>,
  };

  return newNode;
}

export function readmeScrapeCodeGroup(
  node: HastNode,
  _: HastNodeIndex,
  parent: HastNodeParent
): Element | undefined {
  if (
    node.tagName !== 'div' ||
    !node.properties.className ||
    !Array.isArray(node.properties.className) ||
    !node.properties.className.includes('CodeTabs')
  ) {
    return undefined;
  }

  if (node.children.length !== 2 || !node.children[0] || !node.children[1]) return undefined;
  const tabTitles = node.children[0];

  const titles: Array<string> = [];
  visit(tabTitles, 'element', function (subNode) {
    visit(subNode, 'text', function (textNode) {
      titles.push(textNode.value);
      return EXIT;
    });
  });

  assertIsDefined(parent);
  node.children.shift();

  let lang = '';
  visit(node, 'element', function (subNode, _, subParent) {
    if (
      subNode.tagName === 'code' &&
      subParent &&
      subParent.type === 'element' &&
      subParent.tagName === 'pre' &&
      'dataLang' in subNode.properties
    ) {
      lang = subNode.properties.dataLang as string;
      return EXIT;
    }
  });

  const children = turnChildrenIntoMdx(node.children) as Array<ElementContent>;
  const tabChildren: Array<ElementContent> = [];
  for (let childIndex = 0; childIndex < children.length; childIndex++) {
    const child = children[childIndex];
    tabChildren.push({
      type: 'code',
      lang: lang,
      meta: titles[childIndex],
      value: (child as unknown as Code).value,
    } as unknown as ElementContent);
  }

  const newNode: Element = {
    type: 'element',
    tagName: 'CodeGroup',
    properties: {},
    children: tabChildren as Array<ElementContent>,
  };

  return newNode;
}

export function docusaurusScrapeCodeGroup(
  node: HastNode,
  _: HastNodeIndex,
  parent: HastNodeParent
): Element | undefined {
  if (node.tagName !== 'div' || !node.properties.role || node.properties.role !== 'tablist') {
    return undefined;
  }

  if (!tabContainsOnlyCode(node)) return undefined;

  const titles: Array<string> = [];
  visit(node, 'element', function (subNode) {
    if (subNode.tagName !== 'li') return CONTINUE;
    visit(subNode, 'text', function (textNode) {
      titles.push(textNode.value);
      return EXIT;
    });
  });

  assertIsDefined(parent);
  parent.children.shift();

  let lang = '';
  visit(node, 'element', function (subNode) {
    if (Array.isArray(subNode.properties.className) && subNode.properties.className.length > 0) {
      lang = subNode.properties.className[0] as string;
      lang = lang.replace('language-', '');
    }
  });

  const children = turnChildrenIntoMdx(parent.children) as Array<ElementContent>;
  const tabChildren: Array<ElementContent> = [];
  for (let childIndex = 0; childIndex < children.length; childIndex++) {
    const child = children[childIndex];
    tabChildren.push({
      type: 'code',
      lang: lang,
      meta: titles[childIndex],
      value: (child as unknown as Code).value,
    } as unknown as ElementContent);
  }

  const newNode: Element = {
    type: 'element',
    tagName: 'CodeGroup',
    properties: {},
    children: tabChildren as Array<ElementContent>,
  };

  return newNode;
}
