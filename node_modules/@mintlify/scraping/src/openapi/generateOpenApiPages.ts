import { getOpenApiTitleAndDescription, slugToTitle } from '@mintlify/common';
import type {
  DecoratedNavigation,
  DecoratedNavigationGroup,
  Navigation,
  NavigationEntry,
  NavigationGroup,
  DecoratedNavigationPage,
} from '@mintlify/models';
import { validate } from '@mintlify/openapi-parser';
import fse, { outputFile } from 'fs-extra';
import fs from 'fs/promises';
import yaml from 'js-yaml';
import { OpenAPI, OpenAPIV3 } from 'openapi-types';
import { join } from 'path';
import path from 'path';

export const generateOpenApiPages = async (
  pathOrDocument: string | OpenAPI.Document,
  writeFiles?: boolean,
  outDir?: string,
  outDirBasePath?: string
): Promise<{
  nav: Navigation;
  decoratedNav: DecoratedNavigation;
  spec: OpenAPI.Document;
  pagesAcc: Record<string, DecoratedNavigationPage>;
}> => {
  if (typeof pathOrDocument === 'string') {
    const pathname = path.join(process.cwd(), pathOrDocument);
    const file = await fs.readFile(pathname, 'utf-8');

    if (pathOrDocument.endsWith('.yml') || pathOrDocument.endsWith('.yaml')) {
      pathOrDocument = yaml.load(file) as OpenAPI.Document;
    } else {
      pathOrDocument = JSON.parse(file);
    }
  }

  const { errors, schema, valid, version } = await validate(pathOrDocument);

  if (!version || version === '2.0') throw new Error('OpenAPI versions prior to 3.0 not supported');

  if (!valid) {
    const errorMessages = errors
      ? errors
          .map((error) => {
            const path =
              'path' in error
                ? String(error.path)
                    .replace('/paths/', '')
                    .replaceAll('~1', '/')
                    .replaceAll('~2', '~')
                : 'Unknown path';
            return `${path}: ${error.message}`;
          })
          .join('\n')
      : 'An unknown error occurred when trying to validate your OpenAPI spec. Please pass it through an OpenAPI validator and try again.';
    console.error(errorMessages);
    throw new Error(`Failed to validate OpenAPI schema:${errorMessages}`);
  }

  if (!schema) throw new Error('Schema failed to validate. Please try again.');

  if (schema.paths === undefined || Object.keys(schema.paths).length === 0) {
    throw new Error('No paths defined.');
  }

  const nav: Navigation = [];
  const decoratedNav: DecoratedNavigation = [];
  const writePromises: Promise<void>[] = [];
  const pagesAcc: Record<string, DecoratedNavigationPage> = {};
  Object.entries(schema.paths).forEach(([path, pathItemObject]) => {
    if (!pathItemObject || typeof pathItemObject !== 'object') {
      return;
    }
    const typedPathItemObject = pathItemObject as OpenAPIV3.PathItemObject;
    Object.values(OpenAPIV3.HttpMethods).forEach((method) => {
      if (method in typedPathItemObject) {
        const operation = typedPathItemObject[method];
        const groupName = operation?.tags?.[0];
        const title =
          prepareStringToBeValidFilename(operation?.summary) ??
          `${method}-${prepareStringToBeValidFilename(path)}`;
        const folder = prepareStringToBeValidFilename(groupName) ?? '';
        const base = join(outDir ?? '', folder, title);

        const navGroup = findNavGroup<NavigationGroup>(nav, groupName);
        const decoratedNavGroup = findNavGroup<DecoratedNavigationGroup>(decoratedNav, groupName);

        const filenameWithoutExtension = generateUniqueFilenameWithoutExtension(navGroup, base);
        const openapiMetaTag = `${method} ${path}`;
        const { title: titleTag, description } = getOpenApiTitleAndDescription(
          [{ filename: 'filler-filename', spec: schema as OpenAPI.Document }],
          openapiMetaTag
        );
        navGroup.push(filenameWithoutExtension);
        const page: DecoratedNavigationPage = {
          openapi: openapiMetaTag,
          href: join('/', filenameWithoutExtension),
          title: titleTag ?? slugToTitle(filenameWithoutExtension),
          description,
        };
        decoratedNavGroup.push(page);
        pagesAcc[filenameWithoutExtension] = page;
        const targetPath = outDirBasePath
          ? join(outDirBasePath, `${filenameWithoutExtension}.mdx`)
          : `${filenameWithoutExtension}.mdx`;
        if (writeFiles && !fse.pathExistsSync(targetPath)) {
          writePromises.push(createOpenApiFrontmatter(targetPath, method, path));
        }
      }
    });
  });

  await Promise.all(writePromises);

  return {
    nav,
    decoratedNav,
    spec: schema as OpenAPI.Document,
    pagesAcc,
  };
};

// returns the group with the given group name, or the top-level group if no group name is provided
const findNavGroup = <T extends NavigationGroup | DecoratedNavigationGroup>(
  nav: T['pages'][number][],
  groupName?: string
): T['pages'][number][] => {
  if (groupName === undefined) {
    groupName = 'API Reference';
  }
  const group = nav.find(
    (fileOrGroup) =>
      typeof fileOrGroup === 'object' && 'group' in fileOrGroup && fileOrGroup.group === groupName
  ) as T | undefined;
  if (group === undefined) {
    const newGroup = {
      group: groupName,
      pages: [],
    };
    nav.push(newGroup);
    return newGroup.pages;
  } else {
    return group.pages;
  }
};

// returns a filename that is unique within the given array of pages
const generateUniqueFilenameWithoutExtension = (pages: NavigationEntry[], base: string): string => {
  let filename = base;
  if (pages.includes(filename)) {
    let extension = 1;
    filename = `${base}-${extension}`;
    while (pages.includes(filename)) {
      extension += 1;
      filename = `${base}-${extension}`;
    }
  }
  return filename;
};

const createOpenApiFrontmatter = async (
  filename: string,
  method: OpenAPIV3.HttpMethods,
  path: string
) => {
  const data = `---
 openapi: ${method} ${path}
 ---`;

  await outputFile(filename, data);
};

export const prepareStringToBeValidFilename = (str?: string) =>
  str
    ? str
        .replaceAll(' ', '-')
        .replace(/\{.*?\}/g, '-') // remove path parameters
        .replace(/^-/, '')
        .replace(/-$/, '')
        .replace(/[{}(),.'\n\/]/g, '') // remove special characters
        .replaceAll(/--/g, '-') // replace double hyphens
        .toLowerCase()
    : undefined;
