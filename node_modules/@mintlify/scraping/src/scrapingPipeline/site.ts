import { MintConfig, Navigation, Tab } from '@mintlify/models';
import type { Root as HastRoot } from 'hast';
import traverse from 'traverse';

import { NAV_FAILURE_MSG } from '../constants.js';
import { iterateOverNavItems } from '../nav/iterate.js';
import { retrieveNavItems } from '../nav/retrieve.js';
import { retrieveRootNavElement } from '../nav/root.js';
import type { Result } from '../types/result.js';
import { detectFramework, framework } from '../utils/detectFramework.js';
import { logErrorResults } from '../utils/errors.js';
import { startPuppeteer } from '../utils/network.js';
import { INDEX_NAMES, iterateThroughReservedNames } from '../utils/reservedNames.js';
import { removeTrailingSlash } from '../utils/strings.js';
import { scrapePageGroup } from './group.js';
import { downloadFavicon } from './icon.js';
import { downloadLogos } from './logo.js';
import { htmlToHast } from './root.js';

export async function scrapeSite(
  html: string,
  url: string | URL,
  opts: { hast?: HastRoot; tabs?: Array<Tab> } = {}
): Promise<Result<MintConfig>> {
  let hast = opts.hast;
  if (!hast) hast = htmlToHast(html);

  url = new URL(url);
  const origin = url.origin;

  detectFramework(hast);

  const sidebar = retrieveRootNavElement(hast);
  if (!sidebar) return { success: false, message: `${url.toString()}: ${NAV_FAILURE_MSG}` };

  const navItems = retrieveNavItems(sidebar);

  if (origin === '') {
    return { success: false, message: `invalid URL provided to scrape site: ${url}` };
  }

  const listOfLinks = iterateOverNavItems(navItems, origin);
  if (listOfLinks.length === 0) {
    return { success: false, message: `no navigation links were able to be found: ${url}` };
  }

  const needsBrowser = framework.vendor === 'gitbook';

  const externalLinks = listOfLinks.filter((url) => url.origin !== origin);
  const internalLinks = listOfLinks.filter(
    (url) => url.origin === origin && removeTrailingSlash(url.toString()) !== origin
  );
  const rootLinks = listOfLinks.filter(
    (url) => url.origin === origin && removeTrailingSlash(url.toString()) === origin
  );

  const allPathnames = [
    ...internalLinks.map((url) => url.toString()),
    ...rootLinks.map((url) => url.toString()),
  ];
  const rootPaths = rootLinks.map(() => {
    const name = iterateThroughReservedNames(INDEX_NAMES, allPathnames);
    allPathnames.push(name);
    return name;
  });

  try {
    const externalResults = await scrapePageGroup(externalLinks, needsBrowser, {
      externalLinks: true,
    });
    const internalResults = await scrapePageGroup(internalLinks, needsBrowser);
    const rootResults = await scrapePageGroup(rootLinks, needsBrowser, {
      externalLinks: false,
      rootPaths,
    });

    const externalLinkReplaceMap = new Map<string, string>(
      externalResults
        .filter((result) => result.success)
        .map((result) => result.data as [string, string])
    );

    const rootPathReplaceMap = new Map<string, string>(
      rootResults
        .filter((result) => result.success)
        .map((result) => result.data as [string, string])
    );

    traverse(navItems).forEach(function (value) {
      if (typeof value === 'string') {
        if (externalLinkReplaceMap.has(value)) {
          this.update(externalLinkReplaceMap.get(value) ?? value);
        } else if (rootPathReplaceMap.has(value)) {
          this.update(rootPathReplaceMap.get(value) ?? value);
        }
      } else if (Array.isArray(value)) {
        if (value.find((item) => externalLinkReplaceMap.has(item))) {
          this.update(value.map((item) => externalLinkReplaceMap.get(item) ?? item));
        } else if (value.find((item) => rootPathReplaceMap.has(item))) {
          this.update(value.map((item) => rootPathReplaceMap.get(item) ?? item));
        }
      }
    });

    traverse(navItems).forEach(function (value) {
      if (typeof value === 'string') {
        this.update(value.replace('/mintie_overview', ''));
      } else if (Array.isArray(value)) {
        this.update(
          value.map((item) =>
            typeof item === 'string' ? item.replace('/mintie_overview', '') : item
          )
        );
      }
    });

    navItems.forEach((navItem, index) => {
      if (typeof navItem !== 'string') return;
      const name = navItem
        .split('-')
        .map((str) => (str[0] ? `${str[0].toUpperCase()}${str.substring(1)}` : str))
        .join(' ');

      navItems[index] = {
        group: name,
        pages: [navItem],
      };
    });

    logErrorResults('linking to external pages', externalResults);
    logErrorResults('scraping your docs', [...internalResults, ...rootResults]);

    const browser = needsBrowser ? await startPuppeteer() : undefined;

    const favicon = await downloadFavicon(hast);
    const logo = await downloadLogos(url, browser);

    return {
      success: true,
      data: {
        $schema: 'https://mintlify.com/schema.json',
        name: '',
        logo,
        colors: {
          primary: '',
        },
        favicon: favicon ?? '',
        navigation: navItems as Navigation,
        tabs: opts.tabs,
      },
    };
  } catch (error) {
    if (error instanceof Error) {
      return { success: false, message: error.message };
    }
    return {
      success: false,
      message: 'An unknown error occurred when scraping this site. Please try again.',
    };
  }
}
